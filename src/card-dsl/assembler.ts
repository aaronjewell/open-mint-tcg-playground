/**
 * VM Assembler - Converts human-readable assembly to bytecode.
 * 
 * This module provides functionality to convert assembly language text
 * into VM bytecode that can be executed by our virtual machine.
 */

import { Opcode, Target, Stat, EventKind, OpcodeLabel, isOpcode, Comparator, ComparatorLabel, CmpOperandKind } from './types.js';

/**
 * Assembly instruction representation.
 */
export interface AssemblyInstruction {
    /** Instruction mnemonic (e.g., 'HEAL', 'DAMAGE') */
    mnemonic: typeof OpcodeLabel[keyof typeof OpcodeLabel];
    /** Optional arguments (order depends on instruction) */
    args?: Array<string | number>;
    /** Source line number for error reporting */
    line: number;
}

/**
 * Assembly parsing result.
 */
export interface AssemblyResult {
    /** Successfully parsed instructions */
    instructions: AssemblyInstruction[];
    /** Parse errors encountered */
    errors: string[];
}

/**
 * Bytecode generation result.
 */
export interface BytecodeResult {
    /** Generated bytecode bytes */
    bytecode: Uint8Array;
    /** Generation errors */
    errors: string[];
    /** Human-readable disassembly for verification */
    disassembly: string[];
}

/**
 * Parses assembly text into instruction objects.
 */
export function parseAssembly(text: string): AssemblyResult {
    const instructions: AssemblyInstruction[] = [];
    const errors: string[] = [];
    const lines = text.split('\n');

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        const lineNumber = i + 1;

        // Skip empty lines and comments
        if (!line || line.startsWith(';') || line.startsWith('//')) {
            continue;
        }

        // Parse instruction
        const parts = line.split(/\s+/);
        const mnemonic = parts[0].toUpperCase();
        
        if (!isOpcode(mnemonic)) {
            errors.push(`Line ${lineNumber}: Unknown instruction: ${mnemonic}`);
            continue;
        }

        if (parts.length === 1) {
            instructions.push({ mnemonic, line: lineNumber });
        } else {
            const rawArgs = parts.slice(1);
            const args: Array<string | number> = rawArgs.map(a => {
                const n = parseInt(a, 10);
                return isNaN(n) ? a.toUpperCase() : n;
            });
            instructions.push({ mnemonic, args, line: lineNumber });
        }
    }

    return { instructions, errors };
}

/**
 * Converts assembly instructions to bytecode.
 */
export function assembleToBytecode(instructions: AssemblyInstruction[]): BytecodeResult {
    const bytes: number[] = [];
    const errors: string[] = [];
    const disassembly: string[] = [];

    // Add version header
    bytes.push(0x01);
    disassembly.push('0x01 ; VERSION');

    for (const instr of instructions) {
        const startAddr = bytes.length;

        try {
            const opcode = getOpcodeValue(instr.mnemonic);

            bytes.push(opcode);
            let disasm = `0x${opcode.toString(16).padStart(2, '0')} ${instr.mnemonic}`;

            // Handle instructions that require arguments (immediate-arg format)
            switch (instr.mnemonic) {
                case 'WHEN': {
                    const [eventName] = instr.args ?? [];
                    if (typeof eventName !== 'string') { errors.push(`Line ${instr.line}: WHEN requires event name`); continue; }
                    const ev = getEventValue(eventName);
                    if (ev === undefined) { errors.push(`Line ${instr.line}: Unknown event: ${eventName}`); continue; }
                    bytes.push(ev);
                    disasm += ` 0x${ev.toString(16).padStart(2, '0')} (${eventName})`;
                    break;
                }
                case 'HEAL':
                case 'DAMAGE': {
                    const [targetName, amount] = instr.args ?? [] as any;
                    if (typeof targetName !== 'string' || typeof amount !== 'number') { errors.push(`Line ${instr.line}: ${instr.mnemonic} requires TARGET AMOUNT`); continue; }
                    const tv = getTargetValue(targetName);
                    if (tv === undefined) { errors.push(`Line ${instr.line}: Unknown target: ${targetName}`); continue; }
                    if (amount < 0 || amount > 255) { errors.push(`Line ${instr.line}: Amount must be 0-255, got ${amount}`); continue; }
                    bytes.push(tv, amount);
                    disasm += ` 0x${tv.toString(16).padStart(2, '0')} (${targetName}) 0x${amount.toString(16).padStart(2, '0')} (${amount})`;
                    break;
                }
                case 'DESTROY': {
                    const [targetName] = instr.args ?? [];
                    if (typeof targetName !== 'string') { errors.push(`Line ${instr.line}: DESTROY requires TARGET`); continue; }
                    const tv = getTargetValue(targetName);
                    if (tv === undefined) { errors.push(`Line ${instr.line}: Unknown target: ${targetName}`); continue; }
                    bytes.push(tv);
                    disasm += ` 0x${tv.toString(16).padStart(2, '0')} (${targetName})`;
                    break;
                }
                case 'DRAW':
                case 'DISCARD':
                case 'CREATE_TOKEN': {
                    const [amount] = instr.args ?? [] as any;
                    if (typeof amount !== 'number') { errors.push(`Line ${instr.line}: ${instr.mnemonic} requires AMOUNT`); continue; }
                    if (amount < 0 || amount > 255) { errors.push(`Line ${instr.line}: Amount must be 0-255, got ${amount}`); continue; }
                    bytes.push(amount);
                    disasm += ` 0x${amount.toString(16).padStart(2, '0')} (${amount})`;
                    break;
                }
                case 'BUFF_STAT':
                case 'DEBUFF_STAT': {
                    const [targetName, statName, amount] = instr.args ?? [] as any;
                    if (typeof targetName !== 'string' || typeof statName !== 'string' || typeof amount !== 'number') { errors.push(`Line ${instr.line}: ${instr.mnemonic} requires TARGET STAT AMOUNT`); continue; }
                    const tv = getTargetValue(targetName);
                    const sv = getStatValue(statName);
                    if (tv === undefined) { errors.push(`Line ${instr.line}: Unknown target: ${targetName}`); continue; }
                    if (sv === undefined) { errors.push(`Line ${instr.line}: Unknown stat: ${statName}`); continue; }
                    if (amount < 0 || amount > 255) { errors.push(`Line ${instr.line}: Amount must be 0-255, got ${amount}`); continue; }
                    bytes.push(tv, sv, amount);
                    disasm += ` 0x${tv.toString(16).padStart(2, '0')} (${targetName}) 0x${sv.toString(16).padStart(2, '0')} (${statName}) 0x${amount.toString(16).padStart(2, '0')} (${amount})`;
                    break;
                }
                case 'IF': {
                    // Syntax: IF <CMP> <LHS> <RHS>
                    // LHS/RHS each can be: IMM <num>  or  STAT_OF <TARGET> <STAT>
                    const [cmp, ...rest] = instr.args ?? [] as any[];
                    const cmpUpper = typeof cmp === 'string' ? cmp.toUpperCase() : undefined;
                    const cmpOpcode = (cmpUpper === 'EQ' ? Comparator.EQ : cmpUpper === 'GT' ? Comparator.GT : cmpUpper === 'LT' ? Comparator.LT : undefined);
                    if (cmpOpcode === undefined) { errors.push(`Line ${instr.line}: IF requires comparison EQ|GT|LT`); break; }

                    const encodeOperand = (parts: any[], at: number): { n: number; bytes: number[] } | undefined => {
                        const tag = parts[at];
                        if (typeof tag === 'string' && tag.toUpperCase() === 'IMM') {
                            const val = parts[at + 1];
                            if (typeof val !== 'number') return undefined;
                            return { n: 2, bytes: [CmpOperandKind.IMM, val & 0xff] };
                        } else if (typeof tag === 'string' && tag.toUpperCase() === 'STAT_OF') {
                            const tg = parts[at + 1];
                            const st = parts[at + 2];
                            if (typeof st !== 'string' || typeof tg !== 'string') return undefined;
                            const sv = getStatValue(st);
                            const tv = getTargetValue(tg);
                            if (sv === undefined || tv === undefined) return undefined;
                            // Note: encoding order TARGET, STAT to match decoder
                            return { n: 3, bytes: [CmpOperandKind.STAT_OF, tv, sv] };
                        }
                        return undefined;
                    };

                    const lhs = encodeOperand(rest, 0);
                    if (!lhs) { errors.push(`Line ${instr.line}: IF invalid LHS operand`); break; }
                    const rhs = encodeOperand(rest, lhs.n);
                    if (!rhs) { errors.push(`Line ${instr.line}: IF invalid RHS operand`); break; }

                    bytes.push(cmpOpcode, ...lhs.bytes, ...rhs.bytes);
                    disasm += ` ${ComparatorLabel[cmpOpcode]} ...`;
                    break;
                }
                default: {
                    // No-arg instructions
                    if (instr.args && instr.args.length > 0) {
                        errors.push(`Line ${instr.line}: ${instr.mnemonic} does not take arguments`);
                    }
                    break;
                }
            }

            disassembly.push(`${startAddr.toString().padStart(3, ' ')}: ${disasm}`);

        } catch (error) {
            errors.push(`Line ${instr.line}: Error assembling instruction: ${error}`);
        }
    }

    return {
        bytecode: new Uint8Array(bytes),
        errors,
        disassembly
    };
}

/**
 * High-level function to assemble text directly to bytecode.
 */
export function assemble(text: string): BytecodeResult {
    const parseResult = parseAssembly(text);
    
    if (parseResult.errors.length > 0) {
        return {
            bytecode: new Uint8Array(),
            errors: parseResult.errors,
            disassembly: []
        };
    }

    return assembleToBytecode(parseResult.instructions);
}

/**
 * Converts bytecode back to assembly text (disassembler).
 */
export function disassemble(bytecode: Uint8Array): string {
    const lines: string[] = [];
    let i = 0;

    // Check for version header
    if (bytecode.length > 0) {
        lines.push(`; Version: 0x${bytecode[0].toString(16).padStart(2, '0')}`);
        i = 1;
    }

    while (i < bytecode.length) {
        const opcode = bytecode[i++];

        if (!isOpcode(opcode)) {
            lines.push(`; Unknown opcode: 0x${opcode.toString(16).padStart(2, '0')}`);
            continue;
        }
        const mnemonic = getOpcodeName(opcode);

        let line = mnemonic;

        // Handle instructions with arguments (new immediate-arg format)
        switch (mnemonic) {
            case 'WHEN': {
                if (i < bytecode.length) {
                    const event = bytecode[i++];
                    const eventName = getEventName(event);
                    line += ` ${eventName || event}`;
                }
                break;
            }
            case 'HEAL':
            case 'DAMAGE': {
                if (i + 1 <= bytecode.length) {
                    const target = bytecode[i++];
                    const amount = bytecode[i++];
                    const targetName = getTargetName(target);
                    line += ` ${targetName || target} ${amount}`;
                }
                break;
            }
            case 'DESTROY': {
                if (i < bytecode.length) {
                    const target = bytecode[i++];
                    const targetName = getTargetName(target);
                    line += ` ${targetName || target}`;
                }
                break;
            }
            case 'DRAW':
            case 'DISCARD':
            case 'CREATE_TOKEN': {
                if (i < bytecode.length) {
                    const amount = bytecode[i++];
                    line += ` ${amount}`;
                }
                break;
            }
            case 'BUFF_STAT':
            case 'DEBUFF_STAT': {
                if (i + 2 <= bytecode.length) {
                    const target = bytecode[i++];
                    const stat = bytecode[i++];
                    const amount = bytecode[i++];
                    const targetName = getTargetName(target);
                    const statName = getStatName(stat);
                    line += ` ${targetName || target} ${statName || stat} ${amount}`;
                }
                break;
            }
            case 'IF': {
                // cmp, then lhs(kind+payload), rhs(kind+payload)
                if (i < bytecode.length) {
                    const cmp = bytecode[i++];
                    const cmpName = ComparatorLabel[cmp as keyof typeof ComparatorLabel] || cmp;
                    const decodeOperand = (): string => {
                        if (i >= bytecode.length) return 'IMM 0';
                        const kind = bytecode[i++];
                        if (kind === CmpOperandKind.IMM) {
                            if (i < bytecode.length) {
                                const val = bytecode[i++];
                                return `IMM ${val}`;
                            }
                            return 'IMM 0';
                        } else {
                            // STAT_OF <TARGET> <STAT>
                            const target = bytecode[i++];
                            const stat = bytecode[i++];
                            const targetName = getTargetName(target) || target;
                            const statName = getStatName(stat) || stat;
                            return `STAT_OF ${targetName} ${statName}`;
                        }
                    };
                    const lhs = decodeOperand();
                    const rhs = decodeOperand();
                    line += ` ${cmpName} ${lhs} ${rhs}`;
                }
                break;
            }
            case 'END':
                lines.push(line);
                return lines.join('\n');
        }

        lines.push(line);
    }

    return lines.join('\n');
}

// Helper functions for opcode/enum mappings

function getOpcodeValue(mnemonic: typeof OpcodeLabel[keyof typeof OpcodeLabel]): typeof Opcode[keyof typeof Opcode] {
    return Opcode[mnemonic as keyof typeof Opcode];
}

function getOpcodeName(value: typeof Opcode[keyof typeof Opcode]): typeof OpcodeLabel[keyof typeof OpcodeLabel] {
    return OpcodeLabel[value as keyof typeof OpcodeLabel];
}

function getTargetValue(name: string): number | undefined {
    return Target[name as keyof typeof Target];
}

function getTargetName(value: number): string | undefined {
    return Object.keys(Target).find(key => Target[key as keyof typeof Target] === value);
}

function getStatValue(name: string): number | undefined {
    return Stat[name as keyof typeof Stat];
}

function getStatName(value: number): string | undefined {
    return Object.keys(Stat).find(key => Stat[key as keyof typeof Stat] === value);
}

function getEventValue(name: string): number | undefined {
    return EventKind[name as keyof typeof EventKind];
}

function getEventName(value: number): string | undefined {
    return Object.keys(EventKind).find(key => EventKind[key as keyof typeof EventKind] === value);
}
